#!/usr/bin/perl
# see POD at the __END__
use strict;
use warnings;

use Getopt::Long;
use Data::Dumper;
use DBI;

my $input_file      = undef;
my $output_location = undef;         # file for sqlite and htdigest, dsn for DBI (sqlite can be given as DSN as well, of course)
my $output_format   = 'htdigest';    # sqlite,
my $output_arg  = 'djabberd'; # realm for htdigest, nothing for sqlite and query template for DBI

GetOptions(
    'if=s'     => \$input_file,
    'of=s'     => \$output_location,
    'oa=s'     => \$output_arg,
    'format=s' => \$output_format,
);

if($input_file && -r $input_file) {
    my $data = &parse_file($input_file);
    
    if($output_location && $output_format && $output_format =~ m/(?:htdigest|sqlite|dbi)/) {
        if($output_format eq 'htdigest') {
            &write_htdigest($data,$output_location,$output_arg);
        } elsif($output_format eq 'sqlite') {
            &write_sqlite($data,$output_location,$output_arg);
        } elsif($output_format eq 'dbi') {
            &write_dbi($data,$output_location,$output_arg);
        }
    }
}

# Subs
sub write_htdigest {
    my $data = shift;
    my $loc = shift;
    my $realm = shift;
    
    # TODO implement
}

sub write_sqlite {
    # TODO implement
}

sub write_dbi {
    # TODO implement
}

sub parse_file {
    my $file     = shift;
    my $data_ref = {};

    if ( $file && -r $file && open( my $FH, '<', $file ) ) {
        my $buffer = '';
        while ( my $line = <$FH> ) {
            $line = &trim($line);
            $buffer .= $line;
            if ( $buffer =~ m/[}]\.$/ ) {
                $buffer =~ s/\.$//;
                &handle_tlentry( $buffer, $data_ref );
                $buffer = '';
            }
        }
        close($FH);
    }

    print Dumper($data_ref);
    return $data_ref;
}

# handle a top-level entry. it's special because it defines the types we want (or don't) and has a dot
# at the end of each line
sub handle_tlentry {
    my $str = shift;
    my $ref = shift;

    $str =~ s/^[{}]//;
    $str =~ s/[}]\.$//;
    my ( $entry_name, $entry_body ) = split /,/, $str, 2;

    if ( $entry_name eq 'passwd' ) {
        &extract_pw( $ref, $entry_body );
    }
    elsif ( $entry_name eq 'roster' ) {
        &extract_roster( $ref, $entry_body );
    }

    # add vcard and offline_msg?
}

sub extract_pw {
    my $ref = shift;
    my $str = shift;

    if ( $str =~ m/[{]"([^"]+)","([^"]+)"[}],"([^"]+)"/ ) {
        my ( $lp, $domain, $pw ) = ( $1, $2, $3 );
        my $bare_jid = $lp . '@' . $domain;

        $ref->{'authen'}->{$bare_jid} = $pw;
    }
}

sub extract_roster {
    my $ref = shift;
    my $str = shift;

    # RegExp NIGHTMARE!
    if ( $str =~
m/\{"([^"]+)","([^"]+)",\{"([^"]+)","([^"]+)",\[[^]]*\]\}\},\{"([^"]+)","([^"]+)"\},\{"([^"]+)","([^"]+)",\[[^]]*\]\},"([^"]+)",(\w+),(\w+),\[((?:"[^"]+",)*(?:"[^"]+"))?\],<<[^>]*>>,\[[^]]*\]\}/
      )
    {
        my ( $lpfr, $dfr, $lpto, $dto, undef, undef, undef, undef, $name, $auth, $dir, $groups ) = ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 );
        my $barejid_user = $lpfr . '@' . $dfr;
        my $barejid      = $lpto . '@' . $dto;
        my @groups       = split /,/, $groups;
        foreach my $group (@groups) {
            $group =~ s/^"//;
            $group =~ s/"$//;
        }

        $ref->{'roster'}->{$barejid_user}->{$barejid} = {
            'name'   => $name,
            'auth'   => $auth,
            'dir'    => $dir,
            'groups' => [@groups],
        };
    }
}

sub trim {
    my $str = shift;

    $str =~ s/^\s+//;
    $str =~ s/\s+$//s;

    return $str;
}

__END__

=head1 NAME

e2d - a little helper script to help convert users from ejabberd to djabberd

=head1 SYNOPSIS

    e2d.pl ...

=head1 DESCRIPTION

This script parses the files generated by the ejabberd dump command

    ejabberdctl dump /path/to/dump/file
    
This is a pretty dirty implementation. It'd be better done with a proper
grammer and a Parse::RecDescent parser but I'm writing this to get away
from this awful Erlang syntax not to dig even more into it. So RegExp nightmare
it is.
